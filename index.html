<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Non-intrusive signal programming library for C++11">
<title>Synapse</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Uncomment @import statement below to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/

/* Zajo's custom font import. The rest of the customizations are at the bottom of this css file,  which is otherwise kept unchanged */
@import "https://fonts.googleapis.com/css?family=Anonymous+Pro|Istok+Web|Quicksand|Bungee+Hairline";

article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock pre.nowrap,.literalblock pre.nowrap pre,.listingblock pre.nowrap,.listingblock pre.nowrap pre{white-space:pre;word-wrap:normal}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #dddddf}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd){background:#f8f8f7}
table.stripes-none tr,table.stripes-odd tr:nth-of-type(even){background:none}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

/* Zajo's customizations applied on top of the standard asciidoctor css above */
h1{font-size:4em}
h2{font-size:1.74em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.5em}
h4{font-size:1.4em}
h5{font-size:1.125em}
h6{font-size:1em}
h1 code{color:#4101a7; font-size:113%}
h2 code{color:#4101a7; font-size:113%}
h3 code{color:#4101a7; font-size:113%}
h4 code{color:#4101a7; font-size:113%}
h5 code{color:#4101a7; font-size:113%}
#toc {text-align:left}
#toc ul code{font-size:111%}
#toc a:hover code {color:#4101a7}
a:focus{outline:0}
body{text-align:left; background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Istok Web","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#a0a0a0;font-weight:400;margin-top:0;margin-bottom:.25em}
a{color:#000000;text-decoration:underline;line-height:inherit}
a:hover{color:#4101a7}
a:focus{color:#000000}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Quicksand","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#4101a7;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
code{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
*:not(pre)>code{font-size:1.09em;font-style:normal!important;letter-spacing:0;padding:0 0;word-spacing:-.15em;background-color:transparent;-webkit-border-radius:0;border-radius:0;line-height:1.45;text-rendering:optimizeLegibility;word-wrap:break-word}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeLegibility;font-size:1.05em}
kbd{font-family:"Anonymous Pro","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
#header>h1:first-child{font-family:"Bungee Hairline";color:#ff5100;margin-top:2.25rem;margin-bottom:0;letter-spacing:-.17em; font-size:6em}
#toc ul{font-family:"Quicksand","DejaVu Sans",sans-serif;list-style-type:none}
#toc a:hover{color:#4101a7}
#toc.toc2{background-color:#f7f8f7}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#606060}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";color:#606060}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#ff5100}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#ff5100}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#ff5100}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:#606060;-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.exampleblock>.content{background-color:#ffffff;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}

/*
Barlow Semi Condensed
Biryani
Cambay
Carme
Gill Sans
Gothic A1
Gudea
JejuGothic
Mplus 1p
OxygenProza Libre
Roboto
Scada
Signika
Ubuntu
Work Sans
Yantramanav

Doppio One
K2D
Martel Sans
Tauri
*/

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
/*pre.CodeRay {background-color:#f7f7f8;}*/
.CodeRay .line-numbers{border-right:1px solid #d8d8d8;padding:0 0.5em 0 .25em}
.CodeRay span.line-numbers{display:inline-block;margin-right:.5em;color:rgba(0,0,0,.3)}
.CodeRay .line-numbers strong{color:rgba(0,0,0,.4)}
table.CodeRay{border-collapse:separate;border-spacing:0;margin-bottom:0;border:0;background:none}
table.CodeRay td{vertical-align: top;line-height:1.45}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.line-numbers>pre{padding:0;color:rgba(0,0,0,.3)}
table.CodeRay td.code{padding:0 0 0 .5em}
table.CodeRay td.code>pre{padding:0}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Synapse</h1>
<div class="details">
<span id="author" class="author">Non-intrusive signal programming library for C++11</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#_abstract">Abstract</a></li>
<li><a href="#tutorial">Tutorial</a>
<ul class="sectlevel2">
<li><a href="#_signals_emitters_receivers">Signals, emitters, receivers</a></li>
<li><a href="#_emitting_signals_from_objects_of_3rd_party_types">Emitting signals from objects of 3rd-party types</a></li>
<li><a href="#_managing_connection_lifetime">Managing connection lifetime</a></li>
<li><a href="#_blocking_of_signals">Blocking of signals</a></li>
<li><a href="#_meta_signals">Meta signals</a></li>
<li><a href="#_interthread_communication">Interthread communication</a>
<ul class="sectlevel3">
<li><a href="#_emitting_signals_across_thread_boundaries">Emitting signals across thread boundaries</a></li>
<li><a href="#_scheduling_function_calls_across_thread_boundaries">Scheduling function calls across thread boundaries</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#synopsis">Synopsis</a></li>
<li><a href="#reference">Reference</a>
<ul class="sectlevel2">
<li><a href="#emit"><code>emit</code></a></li>
<li><a href="#connect"><code>connect</code></a></li>
<li><a href="#release"><code>release</code></a></li>
<li><a href="#translate"><code>translate</code></a></li>
<li><a href="#connection"><code>connection</code></a></li>
<li><a href="#pconnection"><code>pconnection</code></a>
<ul class="sectlevel3">
<li><a href="#connection::set_user_data"><code>set_user_data</code></a></li>
<li><a href="#connection::get_user_data"><code>get_user_data</code></a></li>
<li><a href="#connection::emitter"><code>emitter</code></a></li>
<li><a href="#connection::receiver"><code>receiver</code></a></li>
</ul>
</li>
<li><a href="#block"><code>block</code></a></li>
<li><a href="#blocker"><code>blocker</code></a>
<ul class="sectlevel3">
<li><a href="#blocker::emitter"><code>emitter</code></a></li>
</ul>
</li>
<li><a href="#thread_local_queue"><code>thread_local_queue</code></a>
<ul class="sectlevel3">
<li><a href="#create_thread_local_queue"><code>create_thread_local_queue</code></a></li>
<li><a href="#poll"><code>poll</code></a></li>
<li><a href="#wait"><code>wait</code></a></li>
<li><a href="#post"><code>post</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#techniques">Programming techniques</a>
<ul class="sectlevel2">
<li><a href="#_monitoring_dynamic_systems">Monitoring dynamic systems</a></li>
<li><a href="#_synapsifying_c_callbacks">Synapsifying C callbacks</a></li>
<li><a href="#_reporting_exceptions_from_noexcept_signal_handlers">Reporting exceptions from <code>noexcept</code> signal handlers</a></li>
<li><a href="#_using_synapse_with_qt_to_avoid_mocing">Using Synapse with Qt to avoid MOCing</a></li>
</ul>
</li>
<li><a href="#_case_study_synapsifying_glfw">Case study: synapsifying GLFW</a></li>
<li><a href="#_alternatives_to_synapse">Alternatives to Synapse</a>
<ul class="sectlevel2">
<li><a href="#_comparison_to_boost_signals2">Comparison to Boost Signals2</a></li>
</ul>
</li>
<li><a href="#_macros_and_configuration">Macros and configuration</a></li>
<li><a href="#_distribution">Distribution</a></li>
<li><a href="#_feedback_support">Feedback / support</a></li>
<li><a href="#_portability">Portability</a></li>
<li><a href="#_building_and_installation">Building and installation</a></li>
<li><a href="#_building_the_unit_tests_and_the_examples">Building the unit tests and the examples</a></li>
<li><a href="#_qa">Q&amp;A</a></li>
<li><a href="#_acknowledgements">Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_abstract">Abstract</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse is a non-intrusive C&#43;&#43; signal programming library. Features:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Register connections and emit signals from any C or C&#43;&#43; object of any type whatsoever.</p>
</li>
<li>
<p>If two contexts share access to a C or C&#43;&#43; object, they can use that object as a randezvouz point, and communicate with each other through Synapse signals.</p>
</li>
<li>
<p>A system of meta signals provides interoperability with other signal programming libraries and callback APIs.</p>
</li>
<li>
<p>In a multi-thread environment signals can be emitted asynchronously and scheduled for synchronous execution when polled in other threads.</p>
</li>
</ul>
</div>
<div class="paragraph text-right">
<p><a href="#tutorial">Tutorial</a> | <a href="#techniques">Programming techniques</a> | <a href="#synopsis">Synopsis</a> | <a href="#reference">Reference</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tutorial">Tutorial</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_signals_emitters_receivers">Signals, emitters, receivers</h3>
<div class="paragraph">
<p>Signal programming libraries allow <em>signals</em> to be associated with emitter objects. Like function types, each signal has a signature. Emitting a signal is similar to function invocation, except it may call multiple functions that currently connect that particular signal from that particular emitter object. Naturally, the signature of any connected function must match the signature of the signal.</p>
</div>
<div class="paragraph">
<p>In Synapse, signals are defined as function pointer typedefs. When a signal is emitted, the value returned from any connected function is discarded, but the return type of the signal definition is still important: it is used as an identifier of the signal, a way to tell apart different signals that have otherwise identical signatures. For example, the following typedefs define two different signals, even though they both take one <code>int</code> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">struct</span> this_signal_;
<span class="keyword">typedef</span> this_signal_(*this_signal)(<span class="predefined-type">int</span>);

<span class="keyword">struct</span> that_signal_;
<span class="keyword">typedef</span> that_signal_(*that_signal)(<span class="predefined-type">int</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two defined signals are different because they use different return types (<code>this_signal_</code> vs. <code>that_signal_</code>). By convention, the return types are defined implicitly within each <code>typedef</code>. This makes the signal definitions more compact:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> this_signal_(*this_signal)(<span class="predefined-type">int</span>);
<span class="keyword">typedef</span> <span class="keyword">struct</span> that_signal_(*that_signal)(<span class="predefined-type">int</span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>To emit a Synapse signal, we instantiate the <code>emit</code> function template with a pre-defined signal <code>typedef</code> (e.g. <code>this_signal</code>), passing the emitter object as the first argument. The rest of the arguments follow, as defined by the signal signature (in this case a single <code>int</code> argument). Note that the emitter object passed as the first argument to <code>emit&lt;S&gt;</code> is not forwarded implicitly to the connected functions; its only purpose is to specify the <em>emitter</em>, that is, which object is emitting the signal <code>S</code>.</p>
</div>
<div class="paragraph">
<p>As a less abstract example, let&#8217;s define a type <code>button</code> that emits a Synapse signal <code>clicked</code> (which takes no arguments) when the member function <code>click</code> is called:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> clicked_(*clicked)();

<span class="keyword">class</span> <span class="class">button</span> {

    <span class="directive">public</span>:

    <span class="directive">void</span> click() {
        synapse::emit&lt;clicked&gt;(<span class="local-variable">this</span>);
    }
};</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
It is possible to define the <code>clicked</code> <code>typedef</code> as a member of <code>class button</code>, but this coupling is usually not appropriate when using Synapse. It is better to treat signals as types with independent semantics that can be used with any appropriate object. In this case, anything clickable could emit the <code>clicked</code> signal.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Next, let&#8217;s connect the signal <code>clicked</code> to the <code>accept</code> member function of a dialog box object:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">class</span> <span class="class">dialog</span> {

    <span class="directive">public</span>:

    <span class="directive">void</span> accept();

};

....
shared_ptr&lt;button&gt; emitter=make_shared&lt;button&gt;();
shared_ptr&lt;dialog&gt; receiver=make_shared&lt;dialog&gt;();
synapse::connect&lt;clicked&gt;(emitter, receiver, &amp;dialog::accept);</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Or we could use a lambda instead:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">synapse::connect&lt;clicked&gt;(emitter, receiver,
    [ ](dialog * d) {
        d-&gt;accept();
    } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>With this setup, <code>click()</code>-ing  the <code>button</code> will <code>accept()</code> the <code>dialog</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>receiver</code> argument to <code>connect</code> is optional. If it is specified, a pointer to the receiver object is passed implicitly as the first argument to the connected function, followed by all other arguments as specified by the signal signature.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_emitting_signals_from_objects_of_3rd_party_types">Emitting signals from objects of 3rd-party types</h3>
<div class="paragraph">
<p>The <code>button</code>/<code>dialog</code> example from the previous section could have been similarly implemented using any other signal programming library, because the <code>button</code> type is specifically designed to be able to emit the <code>clicked</code> signal.</p>
</div>
<div class="paragraph">
<p>But in Synapse, <em>any</em> object whatsoever can be used as an emitter. This makes it possible to <code>emit</code> non-intrusively even if the type of the emitter object was not designed to support signals. For example, a function that processes a file can use a standard <code>FILE</code> pointer as a Synapse emitter to report on its progress:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> report_progress_(*report_progress)(<span class="predefined-type">int</span> progress);

<span class="directive">void</span> process_file( FILE * f ) {

    <span class="keyword">for</span>( <span class="predefined-type">int</span> progress=<span class="integer">0</span>; !feof(f); ) {
        ....
        progress += fread(buf,<span class="integer">1</span>,nread,f);
        ....
        synapse::emit&lt;report_progress&gt;(f,progress);
    }

}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Outside of <code>process_file</code> the <code>report_progress</code> signal can be connected to some user interface function that updates a progress bar. For example, using Synapse, we could easily connect it to a Qt <code>QProgressBar</code> object:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">if</span>( FILE * f=fopen(<span class="string"><span class="delimiter">&quot;</span><span class="content">file.dat</span><span class="delimiter">&quot;</span></span>,<span class="string"><span class="delimiter">&quot;</span><span class="content">rb</span><span class="delimiter">&quot;</span></span>) ) {
    QProgressBar pb(....);
    <span class="directive">auto</span> c=synapse::connect&lt;report_progress&gt;(f, &amp;pb, &amp;QProgressBar::setValue);
    process_file(f);
    fclose(f);
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a> | <a href="#connection"><code>connection</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Notice that <code>process_file</code> is not coupled with <code>QProgressBar</code>: the <code>report_progress</code> signal could be connected to a different function or not connected at all, in which case the call to <code>emit</code> in <code>process_file</code> would be a no-op.</p>
</div>
<div class="paragraph">
<p>The observant reader has surely noticed that in the above example we had to capture the return value of <code>synapse::connect&lt;report_progress&gt;</code> in the local variable  <code>c</code>, while we didn&#8217;t have to do this in the previous <code>button</code>/<code>dialog</code> example. This is explained below.</p>
</div>
</div>
<div class="sect2">
<h3 id="_managing_connection_lifetime">Managing connection lifetime</h3>
<div class="paragraph">
<p>In Synapse there are two types of connection objects: <a href="#connection"><code>connection</code></a> and <a href="#pconnection"><code>pconnection</code></a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> objects are returned by overloads of <a href="#connect"><code>connect</code></a> which take the emitter (and, if specified, the receiver) as a raw pointer. The user is required to keep the <code>connection</code> object alive; the function passed to <code>connect</code> will be disconnected when that object expires.</p>
</li>
<li>
<p><code>weak_ptr&lt;<a href="#pconnection">pconnection</a>&gt;</code> objects are returned by overloads of <a href="#connect"><code>connect</code></a> which take at least one of the emitter or the receiver as a <code>weak_ptr</code> or <code>shared_ptr</code>. The user is <em>not</em> required to keep <code>pconnection</code> objects alive; the connected function is disconnected when Synapse detects that the emitter or the receiver have expired.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The <a href="#release"><code>release</code></a> function can be used to convert a <a href="#pconnection"><code>weak_ptr&lt;pconnection&gt;</code></a> object to a <a href="#connection"><code>shared_ptr&lt;connection&gt;</code></a> object, in case we need to disconnect the function before the receiver or the emitter have expired.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_blocking_of_signals">Blocking of signals</h3>
<div class="paragraph">
<p>It is possible to temporarily block a specific signal for a specific emitter. This allows users to dynamically disable functionality implemented by emitting signals&#8201;&#8212;&#8201;without having to disconnect them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Blocking affects pre-existing as well as future connections.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Example</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/block.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;string&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;iostream&gt;</span>

<span class="keyword">namespace</span> synapse = boost::synapse;

<span class="keyword">typedef</span> <span class="keyword">struct</span> print_(*print)(std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; s);

<span class="predefined-type">int</span> main() {

    <span class="predefined-type">int</span> emitter;

    <span class="directive">auto</span> c = synapse::connect&lt;print&gt;(&amp;emitter,
        [ ](std::<span class="predefined-type">string</span> <span class="directive">const</span> &amp; s) {
            std::cout &lt;&lt; s;
        } );

    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>

    shared_ptr&lt;synapse::blocker&gt; b = synapse::block&lt;print&gt;(&amp;emitter); <i class="conum" data-value="2"></i><b>(2)</b>
    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">no-op</span><span class="delimiter">&quot;</span></span>);

    b.reset();
    synapse::emit&lt;print&gt;(&amp;emitter,<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>emit</code> calls the connected lambda, printing <code>Hello World</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>print</code> signal will be blocked until <code>b</code> expires, therefore the call to <code>emit</code> on the next line is a no-op, even though the signal is still connected.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>At this point <code>b</code> has expired, so the call to <code>emit</code> will call the connected lambda, printing <code>Hello World</code>, again.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a> | <a href="#connect"><code>connect</code></a> | <a href="#connection"><code>connection</code></a> | <a href="#block"><code>block</code></a> | <a href="#blocker"><code>blocker</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_meta_signals">Meta signals</h3>
<div class="paragraph">
<p>Synapse features a special global emitter that emits meta signals to notify connected functions about user interactions with other signals. It can be accessed by the <a href="#meta::connected"><code>meta::emitter</code></a> function.</p>
</div>
<div class="paragraph">
<p>When a signal <code>S</code> is blocked or unblocked, the meta emitter emits the <code>meta::blocked&lt;S&gt;</code> signal. Connecting this <code>meta::blocked&lt;S&gt;</code> signal allows the blocked state of the signal <code>S</code> to be automatically reflected in other systems, for example in user interface.</p>
</div>
<div class="paragraph">
<p>Similarly, when a signal <code>S</code> is connected or disconnected, the meta emitter emits the <a href="#meta::connected"><code>meta::connected&lt;S&gt;</code></a> signal, which is useful when integrating Synapse with 3rd-party callback systems; see <a href="#_synapsifying_c_callbacks">Synapsifying C callbacks</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To further facilitate interoperability between Synapse and other callback APIs, <a href="#connection"><code>connection</code></a>/<a href="#pconnection"><code>pconnection</code></a>  objects (returned by overloads of <a href="#connect"><code>connect</code></a>) can store arbitrary user data.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_interthread_communication">Interthread communication</h3>
<div class="sect3">
<h4 id="_emitting_signals_across_thread_boundaries">Emitting signals across thread boundaries</h4>
<div class="paragraph">
<p>Synapse can be used to implement interthread communication using signals. The data structures created by <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) use thread-local storage, so by default calling <a href="#emit"><code>emit</code></a> will call only functions connected by the calling thread (and will not return until all such functions have been called in order, or one of them throws.)</p>
</div>
<div class="paragraph">
<p>The following diagram shows the connections created (by calls to <code><a href="#connect">connect</a>&lt;S&gt;</code>) in a single thread for a given signal type <code>S</code>, each connecting an emitter to a function. When <code><a href="#emit">emit</a>&lt;S&gt;(e1,arg,&#8230;&#8203;)</code> is called, all functions connecing the signal <code>S</code> from the given emitter <code>e1</code> are called in the order in which the connections were created:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="fig1.png" alt="fig1">
</div>
</div>
<div class="paragraph">
<p>It is also possible for any thread to request to receive all signals emitted by other threads, by creating its own <a href="#thread_local_queue"><code>thread_local_queue</code></a> object.</p>
</div>
<div class="paragraph">
<p>In this case, <em>in addition</em> to the behavior described above, <code><a href="#emit">emit</a>&lt;S&gt;(e1,arg,&#8230;&#8203;)</code> will capture its arguments (depending on the signature of <code>S</code>) and queue them into the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object created by any thread <em>other</em> than the calling thread. Each such thread must poll its own <a href="#thread_local_queue"><code>thread_local_queue</code></a> regularly; this "emits" the queued objects locally and removes them from the queue (note that <a href="#poll"><code>poll</code></a> is not given an emitter or a signal type, it emits locally all queued objects, regardless of signal type or emitter).</p>
</div>
<div class="paragraph">
<p>This is illustrated by the following diagram:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="fig2.png" alt="fig2">
</div>
</div>
<div class="paragraph">
<p>A typical use case for this system is to update user interface objects with data generated by one or multiple worker threads: the user interface objects themselves need not be thread-safe, because they will be updated only synchronously, at the time <a href="#poll"><code>poll</code></a> is called.</p>
</div>
<div class="paragraph">
<p>Special care must be taken to ensure that any objects referred to by arguments passed to <a href="#emit"><code>emit</code></a> will remain valid at least until all other threads have polled their <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects. For example, the following code is incorrect in the presence of <code>thread_local_queue</code> objects:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> my_signal_(*my_signal)( <span class="predefined-type">int</span> * );

<span class="directive">void</span> emit_my_signal( <span class="directive">void</span> * emitter, <span class="predefined-type">int</span> x ) {
    emit&lt;my_signal&gt;(emitter,&amp;x); <span class="comment">//Undefined behavior in the presence of thread_local_queues!</span>
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>The problem is that the address of <code>x</code> may be queued into other threads' queues, and since <code>x</code> is local to <code>emit_my_signal</code>, it may be destroyed by the time these threads call <a href="#poll"><code>poll</code></a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_scheduling_function_calls_across_thread_boundaries">Scheduling function calls across thread boundaries</h4>
<div class="paragraph">
<p>The <a href="#post"><code>post</code></a> function can be used to queue into a <a href="#thread_local_queue"><code>thread_local_queue</code></a> arbitrary functions for execution at the time <a href="#poll"><code>poll</code></a> is called. This feature allows critical worker threads to minimize the amount of time they consume by offloading expensive non-critical computations to another, non-critical thread. This also removes the need for synchronization, since the queued functions are executed synchronously in the thread that owns the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="synopsis">Synopsis</h2>
<div class="sectionbody">
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/emit.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
    <span class="predefined-type">int</span> emit( <span class="directive">void</span> <span class="directive">const</span> *, A... );

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, F f );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, Receiver * r, F f );

    <span class="keyword">class</span> <span class="class">pconnection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, F f ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, &lt;&lt;Receiver&gt;&gt; r, F f ); <i class="conum" data-value="2"></i><b>(2)</b>

    shared_ptr&lt;connection <span class="directive">const</span>&gt; release( weak_ptr&lt;pconnection <span class="directive">const</span>&gt; <span class="directive">const</span> &amp; c );
    shared_ptr&lt;connection&gt; release( weak_ptr&lt;pconnection&gt; <span class="directive">const</span> &amp; c );

    <span class="keyword">namespace</span> meta {

        weak_ptr&lt;<span class="directive">void</span> <span class="directive">const</span>&gt; emitter();

        <span class="keyword">namespace</span> connect_flags {

            <span class="predefined-type">unsigned</span> <span class="directive">const</span> connecting=<span class="integer">1</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> first_for_this_emitter=<span class="integer">2</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> last_for_this_emitter=<span class="integer">4</span>;

        }

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> connected {
            <span class="keyword">typedef</span> connected&lt;Signal&gt;(*type)( connection &amp; c, <span class="predefined-type">unsigned</span> connect_flags cf );
        };
    }

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Two overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Multple overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>; at least one of <code>e</code> and <code>r</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#connection"><code>connection</code></a> |  <code><a href="#connection">pconnection</a></code> | <a href="#connect"><code>connect</code></a> | <a href="#release"><code>release</code></a> | <code><a href="#meta::connected">meta::emitter</a></code> | <code><a href="#meta::connected">meta::connected</a></code></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/translate.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    shared_ptr&lt;connection&gt; translate( OriginalEmitter * e1, TranslatedEmitter * e2 );

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    weak_ptr&lt;pconnection&gt; translate( &lt;&lt;OriginalEmitter&gt;&gt; e1, &lt;&lt;TranslatedEmitter&gt;&gt; e2 ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Multiple overloads are provided: <code>&lt;&lt;OriginalEmitter&gt;&gt;</code> is either <code>OriginalEmitter *</code>, <code>weak_ptr&lt;OriginalEmitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;OriginalEmitter&gt; const &amp;</code>; <code>&lt;&lt;TranslatedEmitter&gt;&gt;</code> by analogy. At least one of <code>e1</code> and <code>e2</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#translate"><code>translate</code></a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connection.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        connection();
        ~connection();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        <span class="directive">void</span> set_user_data( T <span class="directive">const</span> &amp; );

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        T * get_user_data() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;
    };

    <span class="keyword">class</span> <span class="class">pconnection</span>: <span class="directive">protected</span> connection { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        pconnection();
        ~pconnection();

    <span class="directive">public</span>:

        <span class="directive">using</span> connection::set_user_data;
        <span class="directive">using</span> connection::get_user_data;
        <span class="directive">using</span> connection::emitter;
        <span class="directive">using</span> connection::receiver;

    };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connection"><code>connection</code></a> | <a href="#pconnection"><code>pconnection</code></a> | <a href="#connection::set_user_data"><code>set_user_data</code></a> | <a href="#connection::get_user_data"><code>get_user_data</code></a> | <a href="#connection::emitter"><code>emitter</code></a> | <a href="#connection::receiver"><code>receiver</code></a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/block.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>&gt;
    shared_ptr&lt;blocker&gt; block( &lt;&lt;Emitter&gt;&gt; e ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">namespace</span> meta {

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> blocked {
            <span class="keyword">typedef</span> blocked&lt;Signal&gt;(*type)( blocker &amp;, <span class="predefined-type">bool</span> is_blocked );
        };

    }

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Multiple overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#blocker"><code>blocker</code></a> | <a href="#block"><code>block</code></a> | <code><a href="#meta::blocked">meta::blocked</a></code></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/blocker.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        blocker();
        ~blocker();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;
    };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#blocker"><code>blocker</code></a> | <a href="#blocker::emitter"><code>emitter</code></a></p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">struct</span> thread_local_queue;
    shared_ptr&lt;thread_local_queue&gt; create_thread_local_queue();

    <span class="predefined-type">int</span> poll( thread_local_queue &amp; q );
    <span class="predefined-type">int</span> wait( thread_local_queue &amp; q );
    <span class="directive">void</span> post( thread_local_queue &amp; q, function&lt;<span class="directive">void</span>()&gt; <span class="directive">const</span> &amp; f );

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#thread_local_queue"><code>thread_local_queue</code></a> | <a href="#create_thread_local_queue"><code>create_thread_local_queue</code></a> | <a href="#poll"><code>poll</code></a> | <a href="#wait"><code>wait</code></a> | <a href="#post"><code>post</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference">Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="emit"><code>emit</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/emit.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
    <span class="predefined-type">int</span> emit( <span class="directive">void</span> <span class="directive">const</span> *, A... );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Calls all function objects that are connected to the specified <code>Signal</code> from the emitter <code>e</code>, in the order in which they were connected by <a href="#connect"><code>connect</code></a> or <a href="#translate"><code>translate</code></a>, passing the specified arguments depending on the <code>Signal</code> signature, subject to the connection lifetime/blocking restrictions.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The count of the connected function objects that were called. Signals that are currently blocked are not included in the count returned by <code>emit</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
It is the responsibility of the caller to ensure that the emitter object <code>e</code> does not expire before <code>emit</code> returns, otherwise the behavior is undefined.
</td>
</tr>
</table>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Throws: </dt>
<dd>
<p>Any exception thrown by one of the connected function objects, in which case the remaining function objects are not called.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Values returned by the connected function objects are discarded.</p>
</li>
<li>
<p>If before <code>emit</code> returns <a href="#connect"><code>connect</code></a> is called on the same signal and the same emitter, any newly connected functions are not called during the same <code>emit</code>.</p>
</li>
<li>
<p>If before <code>emit</code> returns a <a href="#connection"><code>connection</code></a> object expires, it may or may not get called during the same <code>emit</code>.</p>
</li>
<li>
<p>If <code>e</code> is <code>0</code>, <code>emit</code> simply returns <code>0</code> without calling any functions. Because of this feature, if the emitter is held by a <code>shared_ptr</code> object <code>sp</code>, there is no harm in calling <code>emit&lt;Signal&gt;(sp.get(),&#8230;&#8203;)</code> even if <code>sp</code> is empty. Similarly, if the caller holds a <code>weak_ptr</code> reference <code>wp</code> to an emitter object which has expired, calling <code>emit&lt;Signal&gt;(wp.lock().get(),&#8230;&#8203;)</code> will simply return <code>0</code>.</p>
</li>
<li>
<p><code>emit</code> takes its arguments by value. Use <code>std::ref</code> to pass by reference (but beware of <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects).</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Thread safety: </dt>
<dd>
<p>By default <code>emit</code> will only call functions connected from the calling thread. In addition, the signal is pushed onto any <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects created by other threads, but only if those threads currently have at least one active connection for the specified <code>Signal</code>. In this case <code>emit</code> captures its arguments similarly to <code>std::bind</code>, and it is the responsibility of the caller to ensure that they remain valid until the posted signal is processed in all other threads, by a call to <a href="#poll"><code>thread_local_queue::poll</code></a> or <a href="#wait"><code>thread_local_queue::wait</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="connect"><code>connect</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, F f );

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    shared_ptr&lt;connection&gt; connect( Emitter * e, Receiver * r, F f );

    <span class="keyword">class</span> <span class="class">pconnection</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, F f ); <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>,<span class="keyword">class</span> <span class="class">Receiver</span>,<span class="keyword">class</span> <span class="class">F</span>&gt;
    weak_ptr&lt;pconnection&gt; connect( &lt;&lt;Emitter&gt;&gt; e, &lt;&lt;Receiver&gt;&gt; r, F f ); <i class="conum" data-value="2"></i><b>(2)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Two overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Multiple overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code>  is <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt; const &amp;</code>; at least one of <code>e</code> and <code>r</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Overloads of <code>connect</code> that return <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> create connections whose lifetime is explicitly managed by the user. Such connections require that the caller keeps the returned <a href="#connection"><code>connection</code></a> object alive for as long as the connection should persist.</p>
</div>
<div class="paragraph">
<p>Overloads of <code>connect</code> that return <code>weak_ptr&lt;<a href="#pconnection">pconnection</a>&gt;</code> take at least one of <code>e</code> and <code>r</code> as a <code>weak_ptr</code> or <code>shared_ptr</code>. They create <em>persistent</em> connections which expire automatically when either <code>e</code> or <code>r</code> expire.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Connects the specified <code>Signal</code> from the emitter <code>e</code> to the function object <code>f</code>. The arguments of <code>F</code> must match the arguments of <code>Signal</code>, except that if <code>r</code> is specified, a pointer to the receiver object is passed as the first argument to <code>F</code>, followed by the rest of the arguments as specified by the <code>Signal</code> signature. The signal is considered disconnected when either of the following occurs:</p>
<div class="ulist">
<ul>
<li>
<p>The returned <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code> object expires (this applies only to overloads that return <code>shared_ptr&lt;<a href="#connection">connection</a>&gt;</code>);</p>
</li>
<li>
<p><code>e</code> (passed as either <code>weak_ptr&lt;Emitter&gt;</code> or <code>shared_ptr&lt;Emitter&gt;</code>) expires;</p>
</li>
<li>
<p><code>r</code> (passed as either <code>weak_ptr&lt;Emitter&gt;</code> or <code>shared_ptr&lt;Emitter&gt;</code>) expires.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned object does not assume ownership of <code>e</code> or <code>r</code>: passing <code>shared_ptr</code> to <code>connect</code> is equivalent to passing <code>weak_ptr</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If either the emitter or the receiver, if passed as raw pointers, expire before the returned <a href="#connection"><code>connection</code></a> object has expired, the behavior is undefined.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><a id="meta::connected"></a> The <code>meta::emitter</code> emits the <code>meta::connected&lt;Signal&gt;</code> signal:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">namespace</span> meta {

        weak_ptr&lt;<span class="directive">void</span> <span class="directive">const</span>&gt; emitter();

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
        <span class="keyword">struct</span> connected {
            <span class="comment">//unspecified</span>
        };

        <span class="keyword">namespace</span> connect_flags {
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> connecting=<span class="integer">1</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> first_for_this_emitter=<span class="integer">2</span>;
            <span class="predefined-type">unsigned</span> <span class="directive">const</span> last_for_this_emitter=<span class="integer">4</span>;
        }

    }

} }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>meta::connected&lt;Signal&gt;</code> signal is also emitted when the returned object expires. Handlers of the meta signal take a reference to the <a href="#connection"><code>connection</code></a> object being created or destroyed, and a second <code>unsigned</code> argument, <code>flags</code>, which indicates the circumstances under which the meta signal is emitted:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the <a href="#connection"><code>connection</code></a> object is being created, the <code>connecting</code> bit is set, otherwise it is clear;</p>
</li>
<li>
<p>If this is the first <code>Signal</code> connection being created for the emitter <code>e</code>, the <code>first_for_this_emitter</code> bit is set, otherwise it is clear;</p>
</li>
<li>
<p>If this is the last <code>Signal</code> connection being destroyed for the emitter <code>e</code>, the <code>last_for_this_emitter</code> bit is set, otherwise it is clear.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>Because class <a href="#connection"><code>connection</code></a> is the protected base of class <a href="#pconnection"><code>pconnection</code></a>, handlers of <code>meta::connected&lt;Signal&gt;</code> take <code>connection &amp;</code> regardless of which <code>connect</code> overload was used.</p>
</li>
<li>
<p>The <code>meta::connected&lt;Signal&gt;</code> signal is thread-local; it will never be queued into other threads' <code>thread_local_queue</code> objects.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The passed <a href="#connection"><code>connection</code></a> object can be used to access the emitter and receiver objects passed to <code>connect</code>.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
</dd>
<dt class="hdlist1">Thread safety: </dt>
<dd>
<p>Please see <a href="#emit"><code>emit</code></a> and <a href="#thread_local_queue"><code>thread_local_queue</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="release"><code>release</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connect.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span>;
    <span class="keyword">class</span> <span class="class">pconnection</span>;

    shared_ptr&lt;connection <span class="directive">const</span>&gt; release( weak_ptr&lt;pconnection <span class="directive">const</span>&gt; <span class="directive">const</span> &amp; c );
    shared_ptr&lt;connection&gt; release( weak_ptr&lt;pconnection&gt; <span class="directive">const</span> &amp; c );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Converts a weak <a href="#pconnection"><code>pconnection</code></a> reference to shared ownership <a href="#connection"><code>connection</code></a> reference. The lifetime of the connection is now explicitly managed by the returned <code>shared_ptr</code> object; see <a href="#connect"><code>connect</code></a>.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="translate"><code>translate</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/translate.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    shared_ptr&lt;connection&gt; translate( OriginalEmitter * e1, TranslatedEmitter * e2 );

    <span class="keyword">template</span> &lt;
        <span class="keyword">class</span> <span class="class">OriginalSignal</span>,  <span class="keyword">class</span> <span class="class">TranslatedSignal</span>,
        <span class="keyword">class</span> <span class="class">OriginalEmitter</span>, <span class="keyword">class</span> <span class="class">TranslatedEmitter</span>&gt;
    weak_ptr&lt;pconnection&gt; translate( &lt;&lt;OriginalEmitter&gt;&gt; e1, &lt;&lt;TranslatedEmitter&gt;&gt; e2 ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Multiple overloads are provided: <code>&lt;&lt;OriginalEmitter&gt;&gt;</code> is either <code>OriginalEmitter *</code>, <code>weak_ptr&lt;OriginalEmitter&gt; const &amp;</code> or, equivalently, <code>shared_ptr&lt;OriginalEmitter&gt; const &amp;</code>; <code>&lt;&lt;TranslatedEmitter&gt;&gt;</code> by analogy. At least one of <code>e1</code> and <code>e2</code> is <em>not</em> a raw pointer.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The <code>translate</code> function template creates a connection which causes the emitter <code>e2</code> to emit <code>TranslatedSignal</code> each time the emitter <code>e1</code> emits <code>OriginalSignal</code> (the two signals must have compatible signatures). This behavior persists until:</p>
<div class="ulist">
<ul>
<li>
<p>the returned <a href="#connection"><code>connection</code></a> object expires (this applies only to the <code>translate</code> overload that takes <code>e1</code> and <code>e2</code> as raw pointers);</p>
</li>
<li>
<p><code>e1</code> (passed as either <code>weak_ptr</code> or <code>shared_ptr</code> expires;</p>
</li>
<li>
<p><code>e2</code> (passed as either <code>weak_ptr</code> or <code>shared_ptr</code> expires.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The returned <a href="#connection"><code>connection</code></a> object does not assume ownership of <code>e1</code> or <code>e2</code>: passing <code>shared_ptr</code> is equivalent to passing <code>weak_ptr</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If either <code>e1</code> or <code>e2</code>, passed as raw pointers, expire before the returned <a href="#connection"><code>connection</code></a> object has expired, the behavior is undefined.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="connection"><code>connection</code></h3>

</div>
<div class="sect2">
<h3 id="pconnection"><code>pconnection</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/connection.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">connection</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        connection();
        ~connection();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        <span class="directive">void</span> set_user_data( T <span class="directive">const</span> &amp; );

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        T * get_user_data() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;
    };

    <span class="keyword">class</span> <span class="class">pconnection</span>: <span class="directive">protected</span> connection { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        pconnection();
        ~pconnection();

    <span class="directive">public</span>:

        <span class="directive">using</span> connection::set_user_data;
        <span class="directive">using</span> connection::get_user_data;
        <span class="directive">using</span> connection::emitter;
        <span class="directive">using</span> connection::receiver;

    };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connection::set_user_data"><code>set_user_data</code></a> | <a href="#connection::get_user_data"><code>get_user_data</code></a> | <a href="#connection::emitter"><code>emitter</code></a> | <a href="#connection::receiver"><code>receiver</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Overloads of <a href="#connect"><code>connect</code></a> and <a href="#translate"><code>translate</code></a> return either <code>shared_ptr&lt;connection&gt;</code>  or <code>weak_ptr&lt;pconnection&gt;</code>, depending on whether or not the emitter and the receiver are passed as raw pointers. The former is used to control the lifetime of the connection explicitly, while the latter represents persisent connections, which expire implicitly with the expiration of the emitter or the receiver object.</p>
</div>
<div class="paragraph">
<p>Before being returned to the caller, <code>connection</code> objects are passed to handlers of the <a href="#meta::connected"><code>meta::connected</code></a> signal, which can use the <a href="#connection::emitter"><code>emitter</code></a>/<a href="#connection::receiver"><code>receiver</code></a> member function templates to access the emitter/receiver object passed to <a href="#connect"><code>connect</code></a>. The <a href="#connection::set_user_data"><code>set_user_data</code></a>/<a href="#connection::get_user_data"><code>get_user_data</code></a> member function templates can be used to store and access auxiliary information.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Use <a href="#release"><code>release</code></a> to convert a non-owning <code>weak_ptr&lt;pconnection&gt;</code> reference to an owning <code>shared_ptr&lt;connection&gt;</code> reference.
</td>
</tr>
</table>
</div>
<hr>
<div class="sect3">
<h4 id="connection::set_user_data"><code>set_user_data</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
<span class="directive">void</span> set_user_data( T <span class="directive">const</span> &amp; data );</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Description: </dt>
<dd>
<p>Stores a copy of <code>data</code> into <code>this</code>. Use <code>get_user_data</code> to access it.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::get_user_data"><code>get_user_data</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
T * get_user_data() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If <code>this</code> contains object of type <code>T</code> previously copied by a call to <a href="#connection::set_user_data"><code>set_user_data</code></a>, returns a pointer to that data.</p>
</li>
<li>
<p>If <a href="#set_user_data"><code>set_user_data</code></a> has not been called for <code>this</code>, or if the type used to instantiate the <code>set_user_data</code> function template doesn&#8217;t match the type used with <code>get_user_data</code>, returns <code>0</code>.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::emitter"><code>emitter</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <code>shared_ptr</code> that points the emitter that was passed to an overload of the <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) function template that returned the <a href="#connection"><code>connection</code></a> object.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty <code>shared_ptr</code> is returned if:</p>
<div class="ulist">
<ul>
<li>
<p><code>T</code> does not match the static type of the emitter passed to <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>), or</p>
</li>
<li>
<p>the emitter was passed to <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) as a <code>shared_ptr</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the emitter was passed to <a href="#connect"><code>connect</code></a> (or <a href="#tranlate"><code>translate</code></a>) as a raw pointer, the returned <code>shared_ptr</code> points that emitter but does not (can not) keep it alive.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="connection::receiver"><code>receiver</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; receiver() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <code>shared_ptr</code> that points the receiver that was passed to an overload of the <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) function template that returned the <a href="#connection"><code>connection</code></a> object.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty <code>shared_ptr</code> is returned if:</p>
<div class="ulist">
<ul>
<li>
<p>No receiver object was passed to <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>), or</p>
</li>
<li>
<p><code>T</code> does not match the static type of the receiver passed to <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>), or</p>
</li>
<li>
<p>the receiver was passed to <a href="#connect"><code>connect</code></a> (or <a href="#translate"><code>translate</code></a>) as a <code>shared_ptr</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the receiver was passed to <a href="#connect"><code>connect</code></a> (or <a href="#tranlate"><code>translate</code></a>) as a raw pointer, the returned <code>shared_ptr</code> points that receiver but does not (can not) keep it alive.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="block"><code>block</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/block.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span>;

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>,<span class="keyword">class</span> <span class="class">Emitter</span>&gt;
    shared_ptr&lt;blocker&gt; block( &lt;&lt;Emitter&gt;&gt; e ); <i class="conum" data-value="1"></i><b>(1)</b>

} }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Multiple overloads are provided: <code>&lt;&lt;Emitter&gt;&gt;</code> is either <code>Emitter *</code>, <code>weak_ptr&lt;Emitter&gt;</code> or, equivalently, <code>shared_ptr&lt;Emitter&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Blocks the specified <code>Signal</code> from the emitter <code>e</code> until the returned <code>blocker</code> object expires. While the <code>Signal</code> is blocked, calls to <code>emit&lt;Signal&gt;</code> for <code>e</code> are ignored and return <code>0</code>. The returned <code>blocker</code> object does not own <code>e</code> even if <code>block</code> was passed a <code>shared_ptr</code>.</p>
</li>
<li>
<p><a id="meta::blocked"></a> The <a href="#meta::connected"><code>meta::emitter</code></a> emits the <code>meta::blocked&lt;Signal&gt;</code> signal:</p>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse { <span class="keyword">namespace</span> meta {

    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
    <span class="keyword">struct</span> blocked {
        <span class="comment">//unspecified</span>
    };

} } }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>meta::blocked&lt;Signal&gt;</code> signal is also emitted when the returned <a href="#blocker"><code>blocker</code></a> object expires. Handlers of the meta signal take a reference to the <a href="#blocker"><code>blocker</code></a> object being created or destroyed, and a second <code>bool</code> argument, <code>is_blocked</code>, which is true if the signal is becoming blocked, false if it is becoming unblocked.</p>
</div>
</li>
</ol>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>Blocking affects existing as well as future connections.</p>
</li>
<li>
<p>The <code>meta::blocked&lt;Signal&gt;</code> signal is thread-local; it will never be queued into other threads' <code>thread_local_queue</code> objects.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If <code>block</code> is passed a raw pointer, deleting the emitter before the returned <code>blocker</code> object has expired results in undefined behavior.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect2">
<h3 id="blocker"><code>blocker</code></h3>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/blocker.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">class</span> <span class="class">blocker</span> { <span class="comment">//abstract base</span>

    <span class="directive">protected</span>:

        blocker();
        ~blocker();

    <span class="directive">public</span>:

        <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
        shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;
    };

} }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#blocker::emitter"><code>emitter</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <a href="#block"><code>block</code></a> function returns <code>shared_ptr&lt;blocker&gt;</code> that is used to control the time the signal remains blocked. As well, <code>blocker</code> objects are passed to handlers of the <a href="#meta::blocked"><code>meta::blocked</code></a> signal, which can use the <code>emitter</code> member function template to access the emitter object passed to <a href="#block"><code>block</code></a>.</p>
</div>
<hr>
<div class="sect3">
<h4 id="blocker::emitter"><code>emitter</code></h4>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">T</span>&gt;
shared_ptr&lt;T&gt; emitter() <span class="directive">const</span>;</code></pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A <code>shared_ptr</code> that points the emitter that was passed to <a href="#block"><code>block</code></a>.</p>
</dd>
<dt class="hdlist1">Notes: </dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>An empty shared_ptr is returned if:</p>
<div class="ulist">
<ul>
<li>
<p><code>T</code> does not match the static type of the emitter passed to <a href="#block"><code>block</code></a>, or</p>
</li>
<li>
<p>the emitter was passed to <a href="#block"><code>block</code></a> as a <code>shared</code>/<code>weak_ptr</code> and it has expired.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the emitter was passed to <a href="#block"><code>block</code></a> as a raw pointer, the returned <code>shared_ptr</code> points that emitter but does not (can not) keep it alive.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<hr>
</div>
</div>
<div class="sect2">
<h3 id="thread_local_queue"><code>thread_local_queue</code></h3>
<div class="sect3">
<h4 id="create_thread_local_queue"><code>create_thread_local_queue</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="keyword">struct</span> thread_local_queue;
    shared_ptr&lt;thread_local_queue&gt; create_thread_local_queue();

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>A thread-local object that can be used to queue signals emitted asynchronously from other threads. Use <a href="#poll"><code>poll</code></a> to emit the queued signals synchronously into the calling thread. See <a href="#_interthread_communication">Interthread communication</a>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
While any number of threads can use this function to create their own <a href="#thread_local_queue"><code>thread_local_queue</code></a>, it is invalid to create more than one <code>thread_local_queue</code> object per thread.
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="poll"><code>poll</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="predefined-type">int</span> poll( thread_local_queue &amp; q );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Synchronously emits all signals queued asynchronously into <code>q</code> by calls to <a href="#emit"><code>emit</code></a> from other threads. See <a href="#_interthread_communication">Interthread communication</a>.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The total number of signals emitted.</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="wait"><code>wait</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="predefined-type">int</span> wait( thread_local_queue &amp; q );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>The same as <code><a href="#poll">poll</a>(q)</code>, except that it blocks and does not return until at least one signal was delivered.</p>
</dd>
<dt class="hdlist1">Returns: </dt>
<dd>
<p>The total number of signals emitted (always greater than 0).</p>
</dd>
</dl>
</div>
<hr>
</div>
<div class="sect3">
<h4 id="post"><code>post</code></h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">#include &lt;boost/synapse/thread_local_queue.hpp&gt;</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">namespace</span> boost { <span class="keyword">namespace</span> synapse {

    <span class="directive">void</span> post( thread_local_queue &amp; q, function&lt;<span class="directive">void</span>()&gt; <span class="directive">const</span> &amp; f );

} }</code></pre>
</div>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Effects: </dt>
<dd>
<p>Queues <code>f</code> to be called next time <code>q</code> is polled; that is, <code>f</code> will be executed synchronously in the thread that has created <code>q</code>.</p>
</dd>
</dl>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While <a href="#poll"><code>poll</code></a> (or <a href="#wait"><code>wait</code></a>) must be called from the thread that created the <a href="#thread_local_queue"><code>thread_local_queue</code></a> object, <a href="#post"><code>post</code></a> may be called from any thread.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="techniques">Programming techniques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_monitoring_dynamic_systems">Monitoring dynamic systems</h3>
<div class="paragraph">
<p>It is often needed to monitor the operations of a complex dynamic system beyond the facilities available in its public API. One possible option to accomplish this is to use a logging library. Synapse provides another.</p>
</div>
<div class="paragraph">
<p>Consider a dynamic object environment in a video game, where various art assets may be loaded on the fly, cached, and eventually unloaded when they are no longer needed. Such events are typically not accessible through a formal interface because they are implementation details; yet there is still a need to analyze the efficiency of the caching algorithm.</p>
</div>
<div class="paragraph">
<p>Using Synapse, we can easily define a set of signal typedefs to represent such events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> object_loaded_(*object_loaded)( <span class="predefined-type">char</span> <span class="directive">const</span> * type, <span class="predefined-type">char</span> <span class="directive">const</span> * name );
<span class="keyword">typedef</span> <span class="keyword">struct</span> object_unloaded_(*object_unloaded)( <span class="predefined-type">char</span> <span class="directive">const</span> * type, <span class="predefined-type">char</span> <span class="directive">const</span> * name );
<span class="keyword">typedef</span> <span class="keyword">struct</span> cache_miss_(*cache_miss)( <span class="predefined-type">char</span> <span class="directive">const</span> * type, <span class="predefined-type">char</span> <span class="directive">const</span> * name );
<span class="keyword">typedef</span> <span class="keyword">struct</span> cache_hit_(*cache_hit)( <span class="predefined-type">char</span> <span class="directive">const</span> * type, <span class="predefined-type">char</span> <span class="directive">const</span> * name );</code></pre>
</div>
</div>
<div class="paragraph">
<p>As part of the implementation of the <code>object_cache</code> class, we call <a href="#emit"><code>emit</code></a> to signal the corresponding events as they occur:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> object_cache::load_object( <span class="predefined-type">char</span> <span class="directive">const</span> * type, <span class="predefined-type">char</span> <span class="directive">const</span> * name ) {
    ....
    <span class="comment">//load the object</span>
    ....
    synapse::emit&lt;object_loaded&gt;(<span class="local-variable">this</span>,type,name);
}</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>During development, users of the <code>object_cache</code> class may connect the Synapse signals in order to analyze its efficiency, yet there is no need to compile calls to <code>emit</code> out of release builds; typically it is sufficient to not connect the signals. Synapse is carefully designed to support this use case: programs that do not call <a href="#connect"><code>connect</code></a> do not need to link with Synapse.</p>
</div>
<div class="paragraph">
<p>On the other hand, because Synapse connections are dynamic, it is possible to connect the signals only when/if we need to monitor the <code>object_cache</code> operations. For example, they can be connected only while a diagnostic information window is active.</p>
</div>
</div>
<div class="sect2">
<h3 id="_synapsifying_c_callbacks">Synapsifying C callbacks</h3>
<div class="paragraph">
<p>It is common for C APIs to use function pointers to implement callback systems. A typical example is the <code>SSL_set_info_callback</code> function from <a href="https://www.openssl.org/docs/manmaster/man3/SSL_set_info_callback.html">OpenSSL</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c"><span class="directive">void</span> SSL_set_info_callback(SSL *ssl,
        <span class="directive">void</span> (*cb) (<span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once the user calls <code>SSL_set_info_callback</code>, the C function pointed to by <code>cb</code> will be called with state information for <code>ssl</code> during connection setup and use.</p>
</div>
<div class="paragraph">
<p>One difficulty with such low level C APIs is that often the user needs to pass to the callback function program-specific data. Sometimes such callback setters can be given an additional <code>void * user_data</code> argument which they retain and pass verbatim when they invoke the callback function, together with its other arguments. While this solution is rather cumbersome, it&#8217;s not even supported by <code>SSL_set_info_callback</code>.</p>
</div>
<div class="paragraph">
<p>Synapse can be used with this, as well as any other C-style callback API, to install C&#43;&#43; function objects&#8201;&#8212;&#8201;including lambda functions&#8201;&#8212;&#8201;as callbacks. This enables additional objects needed by the callback to be captured as usual.</p>
</div>
<div class="paragraph">
<p>To do this for the <code>SSL_set_info_callback</code> function, we first  define a Synapse signal with a matching signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> SSL_info_callback_(*SSL_info_callback)( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, at global scope or during initialization, we install a handler for the <code>meta::connected&lt;SSL_info_callback&gt;</code> signal, which the <a href="#meta::connected"><code>meta::emitter</code></a> emits every time the user connects or disconnects the <code>SSL_info_callback</code> signal we defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">void</span> emit_fwd( SSL <span class="directive">const</span> * ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val );

<span class="predefined-type">int</span> main( <span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> <span class="directive">const</span> * argv[ ] ) {

    connect&lt;meta::connected&lt;SSL_info_callback&gt; &gt;( meta::emitter(),
        [ ]( connection &amp; c, <span class="predefined-type">unsigned</span> flags ) { <i class="conum" data-value="1"></i><b>(1)</b>

            <span class="keyword">if</span>( flags &amp; meta::connect_flags::connecting ) { <i class="conum" data-value="2"></i><b>(2)</b>

                <span class="keyword">if</span>( flags &amp; meta::connect_flags::first_for_this_emitter ) <i class="conum" data-value="3"></i><b>(3)</b>
                    SSL_set_info_callback(c.emitter&lt;SSL&gt;().get(),&amp;emit_fwd); <i class="conum" data-value="4"></i><b>(4)</b>

            } <span class="keyword">else</span> { <i class="conum" data-value="5"></i><b>(5)</b>

                <span class="keyword">if</span>( flags &amp; meta::connect_flags::last_for_this_emitter ) <i class="conum" data-value="6"></i><b>(6)</b>
                    <span class="keyword">if</span>( <span class="directive">auto</span> ssl = c.emitter&lt;SSL&gt;() ) <i class="conum" data-value="7"></i><b>(7)</b>
                        SSL_set_info_callback(ssl.get(),<span class="integer">0</span>); <i class="conum" data-value="8"></i><b>(8)</b>

            }

        } );

}

<span class="directive">void</span> emit_fwd( SSL <span class="directive">const</span> * ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) {
    emit&lt;SSL_info_callback&gt;(ssl,ssl,type,val);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This lambda function is called every time the user connects or disconnects the <code>SSL_info_callback</code> Synapse signal.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>SSL_info_callback</code> signal is being <em>connected</em>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This is the <em>first</em> time the <code>SSL_info_callback</code> signal is being connected for a particular <code>SSL</code> object (emitter).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Call <a href="#connection::emitter"><code>connection::emitter</code></a> to get the emitter as a <code>shared_ptr&lt;SSL&gt;</code> (we know the emitter is of type <code>SSL *</code>), and then use the OpenSSL API to install a C callback <code>emit_fwd</code>, which uses <code><a href="#emit">emit</a>&lt;SSL_info_callback&gt;</code> to call all connected Synapse functions.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>The <code>SSL_info_callback</code> signal is being <em>disconnected</em>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>This is the <em>last</em> <code>SSL_info_callback</code> connection being destroyed for a particular <code>SSL</code> object (emitter).</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Check if the SSL object is still accessible (it may have been destroyed already).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Uninstall the <code>emit_fwd</code> callback.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a> | <code><a href="#meta::connected">meta::connected</a></code> | <a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Once the above handler for the <code>meta::connected&lt;SSL_info_callback&gt;</code> signal is installed, we can simply use <a href="#connect"><code>connect</code></a> to install a C&#43;&#43; lamda handler for the <code>SSL_info_callback</code> signal we defined:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">shared_ptr&lt;SSL&gt; ssl(SSL_new(ctx),&amp;SSL_free);

connect&lt;SSL_info_callback&gt;( ssl,
    [ ]( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) <span class="directive">noexcept</span> {

    } );</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reporting_exceptions_from_noexcept_signal_handlers">Reporting exceptions from <code>noexcept</code> signal handlers</h3>
<div class="paragraph">
<p>Sometimes connected functions are not permitted to throw exceptions&#8201;&#8212;&#8201;this is usually the case when the callback originates in C code. With Synapse, such exceptions can be reported safely to a C&#43;&#43; context that can store them for later processing.</p>
</div>
<div class="paragraph">
<p>First, we define a Synapse signal we will use to report exceptions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="keyword">typedef</span> <span class="keyword">struct</span> exception_caught_(*exception_caught)();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we take a handler of the <code>SSL_info_callback</code> (see above) as an example, we could modify it like this:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++">shared_ptr&lt;SSL&gt; ssl(SSL_new(ctx),&amp;SSL_free);

connect&lt;SSL_info_callback&gt;( ssl,
    [ ]( <span class="directive">const</span> SSL *ssl, <span class="predefined-type">int</span> type, <span class="predefined-type">int</span> val ) <span class="directive">noexcept</span> {
        <span class="keyword">try</span> {

            <span class="comment">//code which may throw</span>

        } <span class="keyword">catch</span>(...) {

            <span class="predefined-type">int</span> n=synapse::emit&lt;exception_caught&gt;(ssl); <i class="conum" data-value="1"></i><b>(1)</b>
            assert(n&gt;<span class="integer">0</span>); <i class="conum" data-value="2"></i><b>(2)</b>

        }
    } );</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><a href="#emit"><code>emit</code></a> the <code>exception_caught</code> Synapse signal from the <code>ssl</code> object. Handlers of this signal must be able to deal with any exception, for example they can use <code>std::current_exception</code> to capture the exception and rethrow it once control has exited the critical <code>noexcept</code> path.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><a href="#emit"><code>emit</code></a> returns the number of connected functions it called, so this <code>assert</code> ensures that the exception won&#8217;t get ignored.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a> | <a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_synapse_with_qt_to_avoid_mocing">Using Synapse with Qt to avoid MOCing</h3>
<div class="paragraph">
<p>The signal programming API that is used in <a href="https://www.qt.io/">Qt</a> is intrusive: signals must be specified in the definition of each type. For this reason, it is not possible to add signals to existing Qt types. When this is needed, users are directed to define the new signals in their own class which derives from the Qt type they wanted to add signal(s) to.</p>
</div>
<div class="paragraph">
<p><a href="https://wiki.qt.io/Qt_for_Beginners#Creating_custom_signals_and_slots">There is a special example that illustrates this approach</a>. Unfortunately, this requires the use of the proprietary Qt Meta Object Compiler which the author finds cumbersome. Below is the same example modified to use Synapse signals, which requires no MOCing (the changes made to the original program are marked with numbers):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="preprocessor">#define</span> QT_NO_EMIT <span class="comment">//Suppress the #define emit from Qt since it clashes with synapse::emit.</span>
<span class="preprocessor">#include</span> <span class="include">&lt;QtWidgets/QApplication&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;QtWidgets/QPushButton&gt;</span>

<span class="keyword">namespace</span> synapse=boost::synapse;

<span class="keyword">class</span> <span class="class">Window</span> : <span class="directive">public</span> QWidget
{
<span class="directive">public</span>:
    <span class="directive">explicit</span> Window(QWidget *parent = <span class="integer">0</span>);
    <span class="label">signals:</span> <span class="comment">//Not needed with Synapse but okay</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span> counterReached_(*counterReached)(); <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">private</span> slots: <span class="comment">//&lt;-- Not needed with Synapse but okay</span>
    <span class="directive">void</span> slotButtonClicked(<span class="predefined-type">bool</span> checked);
<span class="directive">private</span>:
    <span class="predefined-type">int</span> m_counter;
    QPushButton *m_button;
    shared_ptr&lt;synapse::connection&gt; c_; <i class="conum" data-value="2"></i><b>(2)</b>
};

Window::Window(QWidget *parent) :
    QWidget(parent)
{
     <span class="comment">// Set size of the window</span>
     setFixedSize(<span class="integer">100</span>, <span class="integer">50</span>);

    <span class="comment">// Create and position the button</span>
    m_button = <span class="keyword">new</span> QPushButton(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>, <span class="local-variable">this</span>);
    m_button-&gt;setGeometry(<span class="integer">10</span>, <span class="integer">10</span>, <span class="integer">80</span>, <span class="integer">30</span>);
    m_button-&gt;setCheckable(<span class="predefined-constant">true</span>);

    <span class="comment">// Set the counter to 0</span>
    m_counter = <span class="integer">0</span>;

    connect(m_button,&amp;QPushButton::clicked,
        [<span class="local-variable">this</span>]( <span class="predefined-type">bool</span> checked )
        {
            slotButtonClicked(checked);
        } ); <i class="conum" data-value="3"></i><b>(3)</b>

    c_=synapse::connect&lt;counterReached&gt;(<span class="local-variable">this</span>,&amp;QApplication::quit); <i class="conum" data-value="4"></i><b>(4)</b>
}

<span class="directive">void</span> Window::slotButtonClicked(<span class="predefined-type">bool</span> checked)
{
    <span class="keyword">if</span> (checked)
        m_button-&gt;setText(<span class="string"><span class="delimiter">&quot;</span><span class="content">Checked</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">else</span>
        m_button-&gt;setText(<span class="string"><span class="delimiter">&quot;</span><span class="content">Hello World</span><span class="delimiter">&quot;</span></span>);
    m_counter ++;
    <span class="keyword">if</span> (m_counter == <span class="integer">10</span>)
        synapse::emit&lt;counterReached&gt;(<span class="local-variable">this</span>); <i class="conum" data-value="5"></i><b>(5)</b>
}

<span class="predefined-type">int</span> main(<span class="predefined-type">int</span> argc, <span class="predefined-type">char</span> **argv)
{
    QApplication app (argc, argv);

    Window window;
    window.show();

    <span class="keyword">return</span> app.exec();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Was: <code>void counterReached();</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Needed to keep the Synapse connection alive.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Was: connect(m_button, SIGNAL (clicked(bool)), this, SLOT (slotButtonClicked(bool)));</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Was: <code>connect(this, SIGNAL (counterReached()), QApplication::instance(), SLOT (quit()));</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Was: <code>emit counterReached();</code></td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#connection"><code>connection</code></a> | <a href="#connect"><code>connect</code></a> |  <a href="#emit"><code>emit</code></a></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_case_study_synapsifying_glfw">Case study: synapsifying GLFW</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse integrates well with some C event handling APIs. As an example, let&#8217;s consider <a href="http://www.glfw.org/">GLFW</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan development on the desktop. It provides a simple API for creating windows, contexts and surfaces, <strong>receiving input and events</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is the function provided by GLFW for installing a key event handler for a window:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c">GLFWkeyfun glfwSetKeyCallback( GLFWwindow *window, GLFWkeyfun cbfun );</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>GLFWkeyfun</code> is declared as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c"><span class="keyword">typedef</span> <span class="directive">void</span> (*GLFWkeyfun)( GLFWwindow * window, <span class="predefined-type">int</span> key, <span class="predefined-type">int</span> scancode, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> mods );</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Synapse, we can define signals to represent this as well as all other GLFW <a href="http://www.glfw.org/docs/latest/input_guide.html">input</a> and <a href="http://www.glfw.org/docs/latest/window_guide.html#window_properties">window state</a> events:</p>
</div>
<div class="listingblock">
<div class="title">glfw_signals.hpp:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">extern</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">C</span><span class="delimiter">&quot;</span></span> { <span class="keyword">typedef</span> <span class="keyword">struct</span> GLFWwindow GLFWwindow; }

<span class="keyword">namespace</span> glfw_signals
{
    <span class="comment">//User input callbacks</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span> Key_(*Key)( GLFWwindow *, <span class="predefined-type">int</span> key, <span class="predefined-type">int</span> scancode, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> mods );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> Char_(*Char)( GLFWwindow *, <span class="predefined-type">unsigned</span> <span class="predefined-type">int</span> codepoint );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> CharMods_(*CharMods)( GLFWwindow *, <span class="predefined-type">unsigned</span> <span class="predefined-type">int</span> codepoint, <span class="predefined-type">int</span> mods );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> CursorPos_ (*CursorPos)( GLFWwindow *, <span class="predefined-type">double</span> xpos, <span class="predefined-type">double</span> ypos );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> CursorEnter_(*CursorEnter)( GLFWwindow *, <span class="predefined-type">int</span> entered );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> MouseButton_(*MouseButton)( GLFWwindow *, <span class="predefined-type">int</span> button, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> mods );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> Scroll_(*Scroll)( GLFWwindow *, <span class="predefined-type">double</span> xoffset, <span class="predefined-type">double</span> yoffset );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> Drop_(*Drop)( GLFWwindow *, <span class="predefined-type">int</span> count, <span class="predefined-type">char</span> <span class="directive">const</span> * * paths );

    <span class="comment">//Window state callbacks</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowClose_(*WindowClose)( GLFWwindow * );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowSize_(*WindowSize)( GLFWwindow *, <span class="predefined-type">int</span> width, <span class="predefined-type">int</span> height );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> FramebufferSize_(*FramebufferSize)( GLFWwindow *, <span class="predefined-type">int</span> width, <span class="predefined-type">int</span> height );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowPos_(*WindowPos)( GLFWwindow *, <span class="predefined-type">int</span> xpos, <span class="predefined-type">int</span> ypos );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowIconify_(*WindowIconify)( GLFWwindow *, <span class="predefined-type">int</span> iconified );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowFocus_(*WindowFocus)( GLFWwindow *, <span class="predefined-type">int</span> focused );
    <span class="keyword">typedef</span> <span class="keyword">struct</span> WindowRefresh_(*WindowRefresh)( GLFWwindow * );

    <span class="comment">//This is emitted from the GLFWwindow object to report exceptions from connected signal handlers</span>
    <span class="keyword">typedef</span> <span class="keyword">struct</span> exception_caught_(*exception_caught)( GLFWwindow * );
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, in a different header we install <code>meta::connected</code> signal handlers for the signals above:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">glfw_synapsify.hpp:</div>
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#include</span> <span class="include">&quot;glfw_signals.hpp&quot;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connect.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;boost/synapse/connection.hpp&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&quot;GLFW/glfw3.h&quot;</span>

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">Signal</span>&gt;
<span class="keyword">class</span> <span class="class">synapsifier</span>;

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">R</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
<span class="keyword">class</span> <span class="class">synapsifier</span>&lt;R(*)(GLFWwindow *,A...)&gt;
{
    <span class="keyword">typedef</span> R(*Signal)(GLFWwindow *,A...);
    <span class="keyword">typedef</span> <span class="directive">void</span> (*GLFWfun)( GLFWwindow *,A... );

    <span class="directive">static</span> GLFWfun prev_;

    <span class="comment">//This is the handler that GLFW calls. It emits the corresponding Synapse</span>
    <span class="comment">//signal and calls the previous GLFW handler for the same event, if any.</span>
    <span class="directive">static</span> <span class="directive">void</span> handler( GLFWwindow * w, A... a )
    {
        <span class="directive">using</span> <span class="keyword">namespace</span> boost::synapse;
        <span class="keyword">try</span>
        {
            (<span class="directive">void</span>) emit&lt;Signal&gt;(w,w,a...);
        }
        <span class="keyword">catch</span>(...)
        {
            <span class="comment">//We can't let exceptions propagate up into C code, so the window</span>
            <span class="comment">//emits the exception_caught signal, which (if exceptions are</span>
            <span class="comment">//expected) should be connected to capture and handle the current</span>
            <span class="comment">//exception.</span>
            <span class="predefined-type">bool</span> handled = emit&lt;glfw_signals::exception_caught&gt;(w,w)&gt;<span class="integer">0</span>;
            assert(handled);
        }
        <span class="keyword">if</span>( prev_ )
            prev_(w,a...);
    }

    <span class="directive">public</span>:

    <span class="directive">explicit</span> synapsifier( GLFWfun (*setter)(GLFWwindow *,GLFWfun) )
    {
        <span class="directive">using</span> <span class="keyword">namespace</span> boost::synapse;

        <span class="comment">//Here we connect the Synapse meta::connected&lt;Signal&gt; signal. This</span>
        <span class="comment">//signal is emitted by the meta::emitter() when the Signal is being</span>
        <span class="comment">//connected (the user calls synapse::connect&lt;Signal&gt;) or disconnected</span>
        <span class="comment">//(when the connection expires). The emitter pointer passed to connect</span>
        <span class="comment">//(which in this case is of type GLFWwindow) is stored in the</span>
        <span class="comment">//synapse::connection object passed to the lambda below, and can be</span>
        <span class="comment">//accessed by the connection::emitter member function template.</span>
        connect&lt;meta::connected&lt;Signal&gt; &gt;( meta::emitter(),
            [setter]( connection &amp; c, <span class="predefined-type">unsigned</span> flags )
            {
                <span class="keyword">if</span>( flags&amp;meta::connect_flags::connecting )
                {
                    <span class="comment">//When the Signal is being connected for the first time,</span>
                    <span class="comment">//use the GLFW API to install our handler.</span>
                    <span class="keyword">if</span>( flags&amp;meta::connect_flags::first_for_this_emitter )
                        prev_=setter(c.emitter&lt;GLFWwindow&gt;().get(),&amp;handler);
                }
                <span class="keyword">else</span>
                {
                    <span class="comment">//When the last Signal connection expires, use the GLFW API</span>
                    <span class="comment">//to uninstall our handler and restore the previous handler.</span>
                    <span class="keyword">if</span>( flags&amp;meta::connect_flags::last_for_this_emitter )
                    {
                        GLFWfun p=setter(c.emitter&lt;GLFWwindow&gt;().get(),prev_);
                        assert(p==&amp;handler);
                    }
                }
            } );
    }
};

<span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="class">R</span>,<span class="keyword">class</span><span class="error">.</span>.. A&gt;
<span class="keyword">typename</span> synapsifier&lt;R(*)(GLFWwindow *,A...)&gt;::GLFWfun synapsifier&lt;R(*)(GLFWwindow *,A...)&gt;::prev_;

<span class="comment">//Install all the synapse::meta::connected&lt;....&gt; handlers</span>
synapsifier&lt;glfw_signals::WindowClose&gt; s1(&amp;glfwSetWindowCloseCallback);
synapsifier&lt;glfw_signals::WindowSize&gt; s2(&amp;glfwSetWindowSizeCallback);
synapsifier&lt;glfw_signals::FramebufferSize&gt; s3(&amp;glfwSetFramebufferSizeCallback);
synapsifier&lt;glfw_signals::WindowPos&gt; s4(&amp;glfwSetWindowPosCallback);
synapsifier&lt;glfw_signals::WindowIconify&gt; s5(&amp;glfwSetWindowIconifyCallback);
synapsifier&lt;glfw_signals::WindowFocus&gt; s6(&amp;glfwSetWindowFocusCallback);
synapsifier&lt;glfw_signals::WindowRefresh&gt; s7(&amp;glfwSetWindowRefreshCallback);
synapsifier&lt;glfw_signals::Key&gt; s8(&amp;glfwSetKeyCallback);
synapsifier&lt;glfw_signals::Char&gt; s9(&amp;glfwSetCharCallback);
synapsifier&lt;glfw_signals::CharMods&gt; s10(&amp;glfwSetCharModsCallback);
synapsifier&lt;glfw_signals::CursorPos&gt; s11(&amp;glfwSetCursorPosCallback);
synapsifier&lt;glfw_signals::CursorEnter&gt; s12(&amp;glfwSetCursorEnterCallback);
synapsifier&lt;glfw_signals::MouseButton&gt; s13(&amp;glfwSetMouseButtonCallback);
synapsifier&lt;glfw_signals::Scroll&gt; s14(&amp;glfwSetScrollCallback);
synapsifier&lt;glfw_signals::Drop&gt; s15(&amp;glfwSetDropCallback);</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#emit"><code>emit</code></a> | <a href="#connect"><code>connect</code></a> | <code><a href="#meta::connected">meta::connected</a></code></p>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The above <code>glfw_synapsify.hpp</code> should be included in exactly one compilation unit of a GLFW program, for example the main compilation unit. This will automatically install all <code>meta::connected</code> signal handlers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With this, we simply use <a href="#connect"><code>connect</code></a> to hook up any <code>GLFWwindow</code> event. For example, if we have a <code>GLFWwindow</code> pointer <code>w</code>, we can install a key event handler like so:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="directive">auto</span> c = synapse::connect&lt;glfw_signals::key&gt;(w,
    [ ]( GLFWwindow * w, <span class="predefined-type">int</span> key, <span class="predefined-type">int</span> scancode, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> mods )
    {
        ....
    }</code></pre>
</div>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a></p>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, this is the example from the GLFW <a href="http://www.glfw.org/docs/latest/quick.html">Getting started page</a>, modified to use the "synapsify" framework above (changes to the original example are marked with numbers):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="comment">//========================================================================</span>
<span class="comment">// Simple GLFW example</span>
<span class="comment">// Copyright (c) Camilla Löwy &lt;elmindreda@glfw.org&gt;</span>
<span class="comment">//</span>
<span class="comment">// This software is provided 'as-is', without any express or implied</span>
<span class="comment">// warranty. In no event will the authors be held liable for any damages</span>
<span class="comment">// arising from the use of this software.</span>
<span class="comment">//</span>
<span class="comment">// Permission is granted to anyone to use this software for any purpose,</span>
<span class="comment">// including commercial applications, and to alter it and redistribute it</span>
<span class="comment">// freely, subject to the following restrictions:</span>
<span class="comment">//</span>
<span class="comment">// 1. The origin of this software must not be misrepresented; you must not</span>
<span class="comment">//    claim that you wrote the original software. If you use this software</span>
<span class="comment">//    in a product, an acknowledgment in the product documentation would</span>
<span class="comment">//    be appreciated but is not required.</span>
<span class="comment">//</span>
<span class="comment">// 2. Altered source versions must be plainly marked as such, and must not</span>
<span class="comment">//    be misrepresented as being the original software.</span>
<span class="comment">//</span>
<span class="comment">// 3. This notice may not be removed or altered from any source</span>
<span class="comment">//    distribution.</span>
<span class="comment">//</span>
<span class="comment">//========================================================================</span>

<span class="preprocessor">#include</span> <span class="include">&quot;glfw_synapsify.hpp&quot;</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="keyword">namespace</span> synapse = boost::synapse;

<span class="preprocessor">#include</span> <span class="include">&lt;glad/glad.h&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;GLFW/glfw3.h&gt;</span>

<span class="preprocessor">#include</span> <span class="include">&quot;linmath.h&quot;</span>

<span class="preprocessor">#include</span> <span class="include">&lt;stdlib.h&gt;</span>
<span class="preprocessor">#include</span> <span class="include">&lt;stdio.h&gt;</span>

<span class="directive">static</span> <span class="directive">const</span> <span class="keyword">struct</span>
{
    <span class="predefined-type">float</span> x, y;
    <span class="predefined-type">float</span> r, g, b;
} vertices[<span class="integer">3</span>] =
{
    { -<span class="float">0</span><span class="float">.6f</span>, -<span class="float">0</span><span class="float">.4f</span>, <span class="float">1</span>.f, <span class="float">0</span>.f, <span class="float">0</span>.f },
    {  <span class="float">0</span><span class="float">.6f</span>, -<span class="float">0</span><span class="float">.4f</span>, <span class="float">0</span>.f, <span class="float">1</span>.f, <span class="float">0</span>.f },
    {   <span class="float">0</span>.f,  <span class="float">0</span><span class="float">.6f</span>, <span class="float">0</span>.f, <span class="float">0</span>.f, <span class="float">1</span>.f }
};

<span class="directive">static</span> <span class="directive">const</span> <span class="predefined-type">char</span>* vertex_shader_text =
<span class="string"><span class="delimiter">&quot;</span><span class="content">#version 110</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">uniform mat4 MVP;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">attribute vec3 vCol;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">attribute vec2 vPos;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">varying vec3 color;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">void main()</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    gl_Position = MVP * vec4(vPos, 0.0, 1.0);</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    color = vCol;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;

<span class="directive">static</span> <span class="directive">const</span> <span class="predefined-type">char</span>* fragment_shader_text =
<span class="string"><span class="delimiter">&quot;</span><span class="content">#version 110</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">varying vec3 color;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">void main()</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">{</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">    gl_FragColor = vec4(color, 1.0);</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>
<span class="string"><span class="delimiter">&quot;</span><span class="content">}</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>;

<span class="directive">static</span> <span class="directive">void</span> error_callback(<span class="predefined-type">int</span> error, <span class="directive">const</span> <span class="predefined-type">char</span>* description)
{
    fprintf(stderr, <span class="string"><span class="delimiter">&quot;</span><span class="content">Error: %s</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>, description);
}

<span class="comment">/* <i class="conum" data-value="2"></i><b>(2)</b>
static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
{
    if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
        glfwSetWindowShouldClose(window, GLFW_TRUE);
}
*/</span>

<span class="predefined-type">int</span> main(<span class="directive">void</span>)
{
    GLFWwindow* window;
    GLuint vertex_buffer, vertex_shader, fragment_shader, program;
    GLint mvp_location, vpos_location, vcol_location;

    glfwSetErrorCallback(error_callback);

    <span class="keyword">if</span> (!glfwInit())
        exit(EXIT_FAILURE);

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="integer">2</span>);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="integer">0</span>);

    window = glfwCreateWindow(<span class="integer">640</span>, <span class="integer">480</span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">Simple example</span><span class="delimiter">&quot;</span></span>, <span class="predefined-constant">NULL</span>, <span class="predefined-constant">NULL</span>);
    <span class="keyword">if</span> (!window)
    {
        glfwTerminate();
        exit(EXIT_FAILURE);
    }

    <span class="comment">//glfwSetKeyCallback(window, key_callback); </span><i class="conum" data-value="2"></i><b>(2)</b>

    <span class="directive">auto</span> connected = synapse::connect&lt;glfw_signals::Key&gt;(window, <i class="conum" data-value="3"></i><b>(3)</b>
        [ ]( GLFWwindow * window, <span class="predefined-type">int</span> key, <span class="predefined-type">int</span> <span class="comment">/*scancode*/</span>, <span class="predefined-type">int</span> action, <span class="predefined-type">int</span> <span class="comment">/*mods*/</span> )
        {
            <span class="keyword">if</span> (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
                glfwSetWindowShouldClose(window, GLFW_TRUE);
        } );

    glfwMakeContextCurrent(window);
    gladLoadGLLoader((GLADloadproc) glfwGetProcAddress);
    glfwSwapInterval(<span class="integer">1</span>);

    <span class="comment">// NOTE: OpenGL error checks have been omitted for brevity</span>

    glGenBuffers(<span class="integer">1</span>, &amp;vertex_buffer);
    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);

    vertex_shader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex_shader, <span class="integer">1</span>, &amp;vertex_shader_text, <span class="predefined-constant">NULL</span>);
    glCompileShader(vertex_shader);

    fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment_shader, <span class="integer">1</span>, &amp;fragment_shader_text, <span class="predefined-constant">NULL</span>);
    glCompileShader(fragment_shader);

    program = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);

    mvp_location = glGetUniformLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">MVP</span><span class="delimiter">&quot;</span></span>);
    vpos_location = glGetAttribLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">vPos</span><span class="delimiter">&quot;</span></span>);
    vcol_location = glGetAttribLocation(program, <span class="string"><span class="delimiter">&quot;</span><span class="content">vCol</span><span class="delimiter">&quot;</span></span>);

    glEnableVertexAttribArray(vpos_location);
    glVertexAttribPointer(vpos_location, <span class="integer">2</span>, GL_FLOAT, GL_FALSE,
                          <span class="keyword">sizeof</span>(vertices[<span class="integer">0</span>]), (<span class="directive">void</span>*) <span class="integer">0</span>);
    glEnableVertexAttribArray(vcol_location);
    glVertexAttribPointer(vcol_location, <span class="integer">3</span>, GL_FLOAT, GL_FALSE,
                          <span class="keyword">sizeof</span>(vertices[<span class="integer">0</span>]), (<span class="directive">void</span>*) (<span class="keyword">sizeof</span>(<span class="predefined-type">float</span>) * <span class="integer">2</span>));

    <span class="keyword">while</span> (!glfwWindowShouldClose(window))
    {
        <span class="predefined-type">float</span> ratio;
        <span class="predefined-type">int</span> width, height;
        mat4x4 m, p, mvp;

        glfwGetFramebufferSize(window, &amp;width, &amp;height);
        ratio = width / (<span class="predefined-type">float</span>) height;

        glViewport(<span class="integer">0</span>, <span class="integer">0</span>, width, height);
        glClear(GL_COLOR_BUFFER_BIT);

        mat4x4_identity(m);
        mat4x4_rotate_Z(m, m, (<span class="predefined-type">float</span>) glfwGetTime());
        mat4x4_ortho(p, -ratio, ratio, -<span class="float">1</span>.f, <span class="float">1</span>.f, <span class="float">1</span>.f, -<span class="float">1</span>.f);
        mat4x4_mul(mvp, p, m);

        glUseProgram(program);
        glUniformMatrix4fv(mvp_location, <span class="integer">1</span>, GL_FALSE, (<span class="directive">const</span> GLfloat*) mvp);
        glDrawArrays(GL_TRIANGLES, <span class="integer">0</span>, <span class="integer">3</span>);

        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glfwDestroyWindow(window);

    glfwTerminate();
    exit(EXIT_SUCCESS);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Automatically install <code>meta::connected</code> signal handlers to synapsify GLFW.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Commented-out parts of the original example, and&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;the C&#43;&#43; lambda function connected to the <code>Key</code> Synapse signal from <code>glfw_signals.hpp</code> to handle the <code>Esc</code> key.</td>
</tr>
</table>
</div>
<div class="paragraph text-right">
<p><a href="#connect"><code>connect</code></a> | <a href="#connection"><code>connection</code></a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_alternatives_to_synapse">Alternatives to Synapse</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The unique design feature of Synapse is that it is non-intrusive with respect to the emitter object type. While other libraries provide users with types that can emit signals, Synapse is able to emit any signal from any object of any type whatsoever.</p>
</div>
<div class="paragraph">
<p>For a list of other signal programming libraries, see this <a href="https://en.wikipedia.org/wiki/Signals_and_slots#Alternative_implementations">Wikipedia page</a>.</p>
</div>
<div class="sect2">
<h3 id="_comparison_to_boost_signals2">Comparison to Boost Signals2</h3>
<div class="paragraph">
<p>Because Synapse is formatted for Boost review, people often ask what are the differences between Synapse and <a href="https://www.boost.org/doc/libs/release/doc/html/signals2.html">Boost Signals2</a>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Comparison between Signals2 and Synapse</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Signals2</th>
<th class="tableblock halign-left valign-top">Synapse</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">What is a signal?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An object of type <code>signal&lt;T&gt;</code>, which maintains a list of connected functions, and is callable like <code>std::function&lt;T&gt;</code> is.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A type, a C function pointer <code>typedef</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">How does emitting a signal work?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invoking <code>s(&#8230;&#8203;)</code>, where <code>s</code> is of type <code>signal&lt;T&gt;</code>, calls all connected functions.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invoking <a href="#emit"><code>emit&lt;S&gt;(e,&#8230;&#8203;)</code></a> calls all functions connecting the signal <code>S</code> for the object <code>e</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">What objects can emit signals?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only instances of the <code>signal&lt;T&gt;</code> class template.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Any object of any type whatsoever: the <a href="#emit"><code>emit&lt;S&gt;(e)</code></a> function template takes <code>e</code> as a <code>void</code> pointer.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">How does connecting a signal work?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calling <code>s.connect(f)</code>, where <code>s</code> is of type <code>signal&lt;T&gt;</code>, connects the function <code>f</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calling <a href="#connect"><code>connect&lt;S&gt;(e,f)</code></a> connects the signal <code>S</code> from the emitter object <code>e</code> to the function <code>f</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Support for meta signals?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (not possible, a signal is an object).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes. Connecting a signal of type <code>S</code> emits the signal <a href="#meta::connected"><code>meta::connected&lt;S&gt;</code></a> from the <a href="#meta::connected"><code>meta::emitter</code></a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integration with C-style callback APIs?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No (not possible).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, through meta signals, see <a href="#_synapsifying_c_callbacks">Synapsifying C callbacks</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi-threading support?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, the connection list maintained in each signal object is thread-safe.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, the connection lists are thread-local, and signals are transported to other threads using <a href="#thread_local_queue"><code>thread_local_queue</code></a> objects.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can connected functions return values?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes, there is an elaborate system for dealing with multiple returns when a signal is invoked.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No, but of course it&#8217;s possible to pass an argument by reference or a custom object to collect and/or accumulate the results if needed.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_macros_and_configuration">Macros and configuration</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_ASSERT</pre>
</div>
</div>
<div class="paragraph">
<p>All assertions in Synapse use this macro; if not <code>#defined</code>, Synapse header files <code>#define</code> it as <a href="http://www.boost.org/doc/libs/release/libs/assert/assert.html"><code>BOOST_ASSERT</code></a>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_USE_STD_FUNCTION</pre>
</div>
</div>
<div class="paragraph">
<p>By default, Synapse uses <code>boost::function</code>. If this macro is <code>#defined</code>, it will use <code>std::function</code> instead.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_USE_STD_SMART_PTR</pre>
</div>
</div>
<div class="paragraph">
<p>By default, Synapse uses the following Boost smart pointer components:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>boost::shared_ptr</code></p>
</li>
<li>
<p><code>boost::weak_ptr</code></p>
</li>
<li>
<p><code>boost::make_shared</code></p>
</li>
<li>
<p><code>boost::get_deleter</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>BOOST_SYNAPSE_USE_STD_SMART_PTR</code> is <code>#defined</code>, the corresponding standard components will be used.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_NO_THREADS</pre>
</div>
</div>
<div class="paragraph">
<p>If <code>#defined</code>, Synapse assumes that static storage is equivalent to thread-local storage, and interthread communication support is disabled.</p>
</div>
<div class="paragraph">
<p>If <code>BOOST_SYNAPSE_NO_THREADS</code> is not explicitly <code>#defined</code>, thread-safety depends on <code>BOOST_NO_THREADS</code>.</p>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_THREAD_LOCAL(type,object)</pre>
</div>
</div>
<div class="paragraph">
<p>This macro is used to define objects with static thread-local storage; if not <code>#defined</code>, Synapse header files <code>#define</code> it as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_THREAD_LOCAL(type,object) <span class="directive">static</span> <span class="directive">thread_local</span> type object</code></pre>
</div>
</div>
<div class="paragraph">
<p>or, under <code>BOOST_SYNAPSE_NO_THREADS</code>, as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_THREAD_LOCAL(type,object) <span class="directive">static</span> type object</code></pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_THREAD_LOCAL_INIT(type,object,init)</pre>
</div>
</div>
<div class="paragraph">
<p>This macro is used to define objects with static thread-local storage and provide their initialization; if not <code>#defined</code>, Synapse header files <code>#define</code> it as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_THREAD_LOCAL_INIT(type,object,init) <span class="directive">static</span> <span class="directive">thread_local</span> type object init</code></pre>
</div>
</div>
<div class="paragraph">
<p>or, under <code>BOOST_SYNAPSE_NO_THREADS</code>, as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_THREAD_LOCAL(type,object,init) <span class="directive">static</span> type object init</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>init</code> argument passed will contain parentheses, so when the macro is expanded it results in calling a constructor.
</td>
</tr>
</table>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_STATIC(type,object)</pre>
</div>
</div>
<div class="paragraph">
<p>This macro is used to define objects with static thread-local storage; if not <code>#defined</code>, Synapse header files <code>#define</code> it as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_STATIC(type,object) <span class="directive">static</span> type object</code></pre>
</div>
</div>
<hr>
<div class="listingblock">
<div class="content">
<pre class="nowrap">BOOST_SYNAPSE_STATIC_INIT(type,object,init)</pre>
</div>
</div>
<div class="paragraph">
<p>This macro is used to define objects with static thread-local storage and provide their initialization; if not <code>#defined</code>, Synapse header files <code>#define</code> it as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight nowrap"><code data-lang="c++"><span class="preprocessor">#define</span> BOOST_SYNAPSE_STATIC_INIT(type,object,init) <span class="directive">static</span> type object init</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Except under <code>BOOST_SYNAPSE_NO_THREADS</code>, initialization of objects with static storage is expected to be serialized.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>init</code> argument passed will contain parentheses, so when the macro is expanded it results in calling a constructor.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_distribution">Distribution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse is distributed under the <a href="http://www.boost.org/LICENSE_1_0.txt">Boost Software License, Version 1.0</a>.</p>
</div>
<div class="paragraph">
<p>The source code is available in <a href="https://github.com/zajo/boost-synapse">this GitHub repository</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Synapse is not part of Boost.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_feedback_support">Feedback / support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Please use the <a href="https://lists.boost.org/mailman/listinfo.cgi/boost">Boost Developers mailing list</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_portability">Portability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse requires compiler support for the following C&#43;&#43;11 features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>thread-safe dynamic initialization of local static objects;</p>
</li>
<li>
<p><code>thread_local</code> objects;</p>
</li>
<li>
<p>lambda functions</p>
</li>
<li>
<p><code>&lt;thread&gt;</code></p>
</li>
<li>
<p><code>&lt;atomic&gt;</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://travis-ci.org/zajo/boost-synapse">Synapse Travis CI Builds</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_and_installation">Building and installation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Synapse has been formatted to be submitted for a Boost review, so its directory structure follows the common directory structure for Boost libraries—and it&#8217;s built with Boost Build.</p>
</div>
<div class="paragraph">
<p>Alternatively, just put <code>connect.cpp</code> and either <code>thread_local_queue.cpp</code> or <code>interthread_stub.cpp</code> into your favorite build system, depending on whether or not your program calls <code>create_thread_local_queue</code>. If your program calls the <code>block</code> function, you also need to compile and link <code>block.cpp</code>.</p>
</div>
<div class="paragraph">
<p>However, note that if your program only emits signals (that is, it calls <code>emit</code> but it never creates any connections), there is no need to link any <code>.cpp</code> files; that is, <code>boost/synapse/emit.hpp</code> by itself is an independent header-only library. This way low level libraries that emit signals do not require the user to link Synapse, unless he cares to connect them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_the_unit_tests_and_the_examples">Building the unit tests and the examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The unit tests and the examples can be built within the Boost framework: clone Synapse under the <code>libs</code> subdirectory in your boost installation, then <code>cd</code> into <code>synapse/build/test</code> and execute <code>b2</code> as usual.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_qa">Q&amp;A</h2>
<div class="sectionbody">
<div class="qlist qanda">
<ol>
<li>
<p><em>Is there a way to stop the emit loop before all connected functions have been called?</em></p>
<p>No, except by throwing an exception.</p>
</li>
<li>
<p><em>I am concerned about code size, does Synapse use a lot of templates?</em></p>
<p>Yes, there are templates instantiated for each signal type. This is done so that the dispatch by signal type occurs at compile-time, leaving only emitter dispatch at run-time. However, static types are erased as soon as possible, so template bloat is kept to a minimum.</p>
</li>
<li>
<p><em>I do not need thread-safety, is there a way to configure Synapse to eliminate thread safety overhead?</em></p>
<p>Most data structures in Synapse are not thread-safe, instead they are thread-local. The overhead of using the library across multiple threads is contained only in <code>thread_local_queue.cpp</code>, which is an optional component.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_acknowledgements">Acknowledgements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks to Peter Dimov for his valuable feedback on the Synapse design and for coming up with the perfect name for this library.</p>
</div>
<hr>
<div class="paragraph">
<p><span class="small"><em>&#169; 2015-2018 Emil Dotchevski</em></span></p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
</div>
</div>
</body>
</html>